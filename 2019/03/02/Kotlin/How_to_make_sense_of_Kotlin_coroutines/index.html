<!DOCTYPE html><html lang="ko"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>How to make sense of Kotlin coroutines | Choi's Dev</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-203671947-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">How to make sense of Kotlin coroutines</h1><a id="logo" href="/.">Choi's Dev</a><p class="description">Software Engineer, Backend-Developer</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 홈</i></a><a href="/archives/"><i class="fa fa-archive"> 아카이브</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">How to make sense of Kotlin coroutines</h1><div class="post-meta">2019-03-02<span> | </span><span class="category"><a href="/categories/Kotlin/">Kotlin</a></span></div><div class="post-content"><h1 id="How-to-make-sense-of-Kotlin-coroutines"><a href="#How-to-make-sense-of-Kotlin-coroutines" class="headerlink" title="How to make sense of Kotlin coroutines"></a>How to make sense of Kotlin coroutines</h1><blockquote>
<p>본 글은 <a target="_blank" rel="noopener" href="https://proandroiddev.com/how-to-make-sense-of-kotlin-coroutines-b666c7151b93">How to make sense of Kotlin coroutines</a>을 읽고 발번역(?)한 내용입니다. 영어에 유창한 분들은 링크를 참고해주세요.</p>
</blockquote>
<p>코루틴은 완벽하게 읽고 유지 보수가 가능한 비동기 코드를 작성하는 좋은 방법이다. Kotlin은 단일 언어 구문으로 비동기 프로그래밍의 기본 요소를 제공하는데, 바로 <code>suspend</code> 키워드이다. 이 키워드와 함께 라이브러리 함수가 빛을 발합니다.</p>
<h2 id="What-is-a-coroutine"><a href="#What-is-a-coroutine" class="headerlink" title="What is a coroutine?"></a>What is a coroutine?</h2><p>Kotlin팀은 <code>Coroutine</code>을 <code>경량 스레드: Light-Weighted-Thread</code>로 정의했습니다. <strong>그것들은 실제 스레드가 실행 할 수 있는 일종의 작업입니다.</strong> <a target="_blank" rel="noopener" href="https://kotlinlang.org/">Kotlinlang.org</a>의 배너는 다음과 같습니다.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*OEX52nKgM1SHGO4l1mvV1A.gif"></p>
<p>가장 흥미로운 점은 스레드가 특정 “정지 지점”에서 코루틴 실행을 중지하고 다른 작업을 수행 할 수 있다는 것이다. 나중에 코루틴을 다시 시작하거나 다른 스레드가 처리 할 수 ​​있습니다.</p>
<p>따라서 정확성을 높이기 위해 하나의 코 루틴은 정확하게 하나의 “작업”이 아니라 오히려 특정 보장 된 순서로 실행되는 “하위 작업”의 순서입니다. 코드가 하나의 순차 블록에 있는 것처럼 보이더라도 정지 기능에 대한 각 호출은 동시 루틴 내의 새로운 “하위 작업”의 시작을 제한합니다.</p>
<p>이는 우리에게 <code>suspending functions</code>에 관련된 주제를 다시 던져준다.</p>
<h2 id="Suspending-functions"><a href="#Suspending-functions" class="headerlink" title="Suspending functions"></a>Suspending functions</h2><p>당신은 어쩌면 kotlinx의 <code>delay</code> 또는 Ktor의 <code>HttpClient.post</code>와 같은 함수를 발견 했을 수도 있는데, 이 함수들은 반환되기 전에 무언가를 기다리거나 집중적으로 작업해야하며 suspend 키워드로 표시되어있을 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someNetworkCallReturningValue</span><span class="params">()</span></span>: SomeType &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>우리가 위에서 본 것처럼 이를 <code>suspending function</code>이라고 합니다.</p>
<blockquote>
<p>일시 중단 함수는 현재 스레드를 차단하지 않고 현재 코루틴의 실행을 일시 중단 할 수 있습니다.</p>
</blockquote>
<p>다시 말해, 당신이 보고 있는 코드가 <code>suspending function</code>을 호출하는 순간에 실행을 중지 할 수 있으며 나중에 다시 시작 될 수도 있다는 이야기이다. <strong>그러나, 그 동안 현재 쓰레드가 무엇을 할 지에 대해서는 아무 말도 하지 않는다.</strong></p>
<p>그 시점에서 또 다른 coroutine을 실행하는 것으로 돌아갈 수 있으며, 나중에 우리가 남긴 coroutine을 다시 실행할 수 있습니다. 이 모든 것은 일시 중지되지 않는 함수 세계에서 일시 중지 함수를 호출하는 방법에 의해 제어되지만 함수 일시 중단에 대해 본질적으로 비동기는 없습니다.</p>
<blockquote>
<p>일시 중단 기능은 명시 적으로 사용되는 경우에만 비동기식입니다.</p>
</blockquote>
<p>우리는 나중에 이것을 보게 될 것이다. 그러나 지금 당장은 함수를 일시 정지하는 것으로 생각하면 잠시 시간을내어 선언하는 특수 함수로 간주 할 수 있습니다. 그리고 그들은 암시적으로 스레드의 복잡성과 파견에 대해 걱정할 필요없이 함수를 하위 작업으로 암시 적으로 분할한다는 점을 명심하십시오. 그것이 실제로 그들이 훌륭한 이유입니다. 여러분이 내부에있을 때 걱정할 필요가 없습니다.</p>
<h3 id="The-suspending-world-is-nicely-sequential"><a href="#The-suspending-world-is-nicely-sequential" class="headerlink" title="The suspending world is nicely sequential"></a>The suspending world is nicely sequential</h3><p>아마 <code>suspending function</code>에 특별한 반환 유형이 없는 것을 알아차렸을 수 있다. Java의 <code>Future</code> 또는 JavaScript의 <code>Promise</code>과 같은 래퍼가 필요하지 않습니다. 이것은 <code>Promise</code>을 반환하는 JavaScript의 비동기 함수와 달리 일시 중단 함수가 비동기 적이라는 사실을 강조합니다.</p>
<blockquote>
<p>내부 정지 함수로부터, 함수 호출에 대해 순차적으로 추론 할 수 있습니다.</p>
</blockquote>
<p>이것이 바로 비동기식 소재를 Kotlin에서 쉽게 추론 할 수 있게 하는 이유이다. <code>suspending function</code> 내에서 다른 <code>suspending function</code>에 대한 호출은 일반 함수 호출과 같이 작동합니다. 우리는 반환 값을 얻고 나머지 코드를 실행하기 전에 호출 된 함수의 실행을 기다릴 필요가 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someNetworkCallReturningSomething</span><span class="params">()</span></span>: Something &#123;</span><br><span class="line">    <span class="comment">// some networking operations making use of the suspending mechanism</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someBusyFunction</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;Printed after 1 second&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> something: Something = someNetworkCallReturningSomething()</span><br><span class="line">    println(<span class="string">&quot;Received <span class="variable">$something</span> from network&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이것이 나중에 복잡한 비동기 코드를 간단한 방법으로 작성할 수 있게 해줍니다.</p>
<h3 id="Bridging-the-normal-world-and-the-suspending-world"><a href="#Bridging-the-normal-world-and-the-suspending-world" class="headerlink" title="Bridging the normal world and the suspending world"></a>Bridging the normal world and the suspending world</h3><p>일반 함수에서 <code>suspending function</code>을 직접 호출하면 컴파일 할 수 없다. 이에 대한 일반적인 설명은 <em><code>coroutines</code> 만 일시 중단 될 수 있기 때문에</em> 이라고 설명하고 있다. 이런 설명을 통해 우리는 <code>suspending function</code>을 수행 할 <code>coroutine</code>을 생성해야 한다는 결론을 내릴 수 있다.</p>
<p>개념적으로 함수를 일시 중단하는 것은 선언에서 “실행하는 데 약간의 시간이 걸릴”수 있습니다. 자신이 일시 중지 기능이 아니라면 다음 두 가지 중 하나를 명시 적으로 수행해야합니다.</p>
<ul>
<li>기다리는 동안 실제로 스레드를 차단합니다 (일반적인 함수 호출과 같이).</li>
<li>비동기로 시작하여 즉시 수행하고 (여러 가지 가능한 방법으로 수행 할 수 있음)</li>
</ul>
<p>선택을 표현하는 방법으로 코 루틴 (coroutine)을 생성하는 것을 볼 수 있습니다. 명시 적이어야합니다 (그리고 이것은 대단합니다!) 이것은 coroutine 빌더라고하는 함수를 사용하여 수행됩니다.</p>
<h2 id="Coroutine-builders"><a href="#Coroutine-builders" class="headerlink" title="Coroutine builders"></a>Coroutine builders</h2><p><code>Coroutine Builder</code>는 주어진 <code>suspending function</code>을 실행하는 새로운 <code>Coroutine</code>을 작성하는 간단한 함수입니다. 이러한 <code>Coroutine Builder</code>는 <code>suspending function</code>이 아닌 일반 함수에서 호출될 수 있는데, 왜냐하면 이러한 빌더 함수들은 <code>suspending function</code>이 아니기 때문입니다. 마치 일반 함수와 <code>suspending function</code> 함수 세계와의 가교 역할을 수행한다고 생각하시면 편합니다.</p>
<p>Kotlin 표준 라이브러리에는 여러 가지 <code>Coroutine Builder</code>가 포함되어있어 다양한 작업을 수행 할 수 있습니다. 다음 하위 절에서 몇 가지를 볼 것입니다.</p>
<h3 id="Block-the-current-thread-with-“runBlocking”"><a href="#Block-the-current-thread-with-“runBlocking”" class="headerlink" title="Block the current thread with “runBlocking”"></a>Block the current thread with “runBlocking”</h3><p>코틀린의 일반 함수에서 <code>suspending function</code>을 다루는 가장 간단한 방법은 현제 실행 중인 스레드를 블록하고 기다리는 방법입니다. 현재 스레드를 블록하는 <code>Coroutine Builder</code> 함수는 바로 <code>runBlocking</code>입니다. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 주어진 suspending lambda function을 실행하는 코루틴을 만들 수 있으며</span></span><br><span class="line">    <span class="comment">// 그리고 현재 실행중인 스레드를 해당 함수의 실행이 마무리 될떄까지 블락합니다.</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// coroutine 함수 내부, 함수는 2초동안 정지상태로 유지됨.</span></span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 아래 코드는 2초 뒤에 실행됨</span></span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runBlocking</code>의 컨텍스트에서 주어진 <code>suspending function</code>과 호출 계층 구조에 있는 자식은 실행이 끝날 때까지 현재 스레드를 효과적으로 차단합니다. <code>runBlocking</code>에 전달 된 함수는 서명에서 알 수 있듯이 runBlocking 자체가 일시 중지되지 않고 (스레드 블로킹 인 경우에도) 일시 중단 함수입니다.</p>
<p><img src="https://i.imgur.com/i5aj0dj.png"></p>
<p><code>main()</code> 함수에서 일종의 최상위 코루틴을 제공하고 JVM을 활성 상태로 유지하는 데 종종 사용됩니다 (구조화 된 동시성에 대한 섹션에서 볼 수 있습니다).</p>
<h3 id="Fire-and-forget-with-“launch”"><a href="#Fire-and-forget-with-“launch”" class="headerlink" title="Fire-and-forget with “launch”"></a>Fire-and-forget with “launch”</h3><p>일반적으로 <code>coroutine</code>의 핵심은 스레드를 블록하는 것이 아니라 비동기 작업을 시작하는 것입니다. <code>launch</code>이라는 <code>Coroutine Builder</code>는 백그라운드에서 <code>coroutine</code>을 시작하고 그동안 계속 작업 할 수 있게 합니다.</p>
<p>Kotlin 문서를 통해 아래와 같은 예제를 확인 할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// 새로운 코루틴을 백그라운드에서 실행하고 이후 단계를 진행한다.</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues here immediately    </span></span><br><span class="line">    runBlocking &#123;     <span class="comment">// 그러나 이 표현식은 현제 실행중인 스레드를 블락한다.</span></span><br><span class="line">        delay(<span class="number">2000L</span>)  <span class="comment">// 우리가 2초 가량 대기하는 동안에도 JVM은 살이 있는 상태를 유지한다.        </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>의견은 스스로에 대해 말해야합니다. 그러면 “Hello”가 즉시 인쇄되고 두 번째 후에 “World!”가 추가됩니다. 이 예제의 목적을 위해라도 어찌되었던간에 메인 함수를 블록해야 <code>launch</code>에서 무슨 일이 발생하는지 확인 할 수 있습니다. 그래서 JVM을 계속 유지하기 위해 <code>runBlocking</code>을 여기에서 다시 사용하고 있습니다.</p>
<h3 id="Get-a-result-asynchronously-with-“async”"><a href="#Get-a-result-asynchronously-with-“async”" class="headerlink" title="Get a result asynchronously with “async”"></a>Get a result asynchronously with “async”</h3><p>다음은 값을 반환하는 비동기 작업을 수행 할 수 있는 <code>async</code>라는 또 다른 <code>Coroutine Builder</code>입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferredResult: Deferred&lt;String&gt; = GlobalScope.async &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="string">&quot;World!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello, <span class="subst">$&#123;deferredResult.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>지연 값의 결과를 얻으려면 async가 편리한 Deferred 객체를 반환합니다. 이는 자바의 <code>Future</code> 또는 자바스크립트의 <code>Promise</code>와 같습니다. 지연 값에 대해 <code>await</code>를 호출함으로써 결과를 기다리고 획득 할 수 있습니다.</p>
<p><code>await</code>는 일반적인 블록킹 함수가 아닌 <code>suspending function</code>입니다. 이말인 즉슨, 메인 함수에서 호출 할 수 없다는 것을 의미합니다. 결과를 기다리기 위해 실제 main 함수를 블록해야 해야 되며 그래서 여기서 <code>runBlocking</code>을 사용하여 호출을 대기시킵니다.</p>
<p>날카로운 눈빛을 가진 사람들은 GlobalScope를 다시 보았을 수 있습니다. 그래서 이제 GlobalScope에 대해 이야기 하려고 합니다.<br>GlobalScope란 coroutines의 계층을 만들 수 있는 도구라고 볼 수 있습니다. Kotlin팀은 이를 구조화 된 동시성(<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency">structured concurrency</a>)이라 부르고 있습니다.</p>
<h2 id="Structured-concurrency"><a href="#Structured-concurrency" class="headerlink" title="Structured concurrency"></a>Structured concurrency</h2><p>만약 위에서 봤던 예제들을 잘 따라왔다면, 고전적인 “블록을 완료하고 내 코루틴이 끝날 때까지 기다리는” 패턴을 알아야 할 필요가 있음을 눈치 챘을 것이다.</p>
<p>Java에서는 위에서와 같은 패턴을 구현하는 방법으로 대개 스레드에 대한 참조를 유지하고 모든 스레드를 기다리는 동안 주 스레드를 블록하기 위해 스레드에 대한 참조를 유지하고 모든 스레드에 대한 join을 호출하여 결과를 얻습니다. 우리는 Kotlin의 coroutine을 이용하여 비슷한 일을 할 수 있습니다. 그러나 이것은 전혀 관용적이지 않습니다.</p>
<p>Kotlin에서는 <code>coroutines</code>을 계층 구조로도 생성 할 수 있습니다. 이 계층 구조를 사용하면 부모 coroutine이 자동으로 자식 coroutines의 수명주기를 관리 할 수 ​​있습니다. 예를 들어, 하위 코루틴의 실행이 완료 할 때까지 기다리는 일도, 그 중 하나에서 예외가 발생하는 경우 모든 하위 코루틴의 실행을 취소 할 수 있습니다.</p>
<h3 id="Creating-a-hierarchy-of-coroutines"><a href="#Creating-a-hierarchy-of-coroutines" class="headerlink" title="Creating a hierarchy of coroutines"></a>Creating a hierarchy of coroutines</h3><p><code>coroutine</code>에서 호출하면 안되는 <code>runBlocking</code>을 제외하고 모든 <code>Coroutine Builder</code>는 <code>CoroutineScope</code> 클래스의 확장 함수 형태로 선언되어 있는데, <code>coroutine</code>을 구조화하도록 권장합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(...)</span></span>: T &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(...)</span></span>: Deferred&lt;T&gt; &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">launch</span><span class="params">(...)</span></span>: Job &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> CoroutineScope.<span class="title">produce</span><span class="params">(...)</span></span>: ReceiveChannel&lt;E&gt; &#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Coroutine을 생성하려면 GlobalScope (최상위 수준, Top-Level Coroutine) 또는 이미 존재하는 <code>CoroutineScope</code> (해당 범위의 자식 Coroutine)에서 이러한 빌더를 호출해야합니다.</p>
<p>In fact, if you write a function that creates coroutines, you should declare it as an extension of the CoroutineScope class too<br>사실, <code>coroutine</code>을 만드는 함수를 작성한다면 <code>CoroutineScope</code> 클래스의 확장으로 선언해야합니다. 이는 관례적으로 <code>Coroutine Builder</code>를 쉽게 호출 할 수 있게 해주는데, 왜냐하면 <code>Coroutine Scope</code>에 대한 참조를 <code>this</code>를 통하여 할 수 있기 때문입니다.</p>
<p><code>Coroutine Builder</code>의 매소드 시그니처를 살펴보면 매개 변수로 사용하는 <code>suspending function</code>이 <code>CoroutineScope</code> 클래스의 확장 기능으로 정의되어 있음을 알 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이는 수신자를 지정하지 않고도 그 함수의 내부에서 다른 <code>Coroutine Builder</code>를 호출 할 수 있음을 의미합니다. 그리고, 암시적인 수신자는 현재 코루틴의 자식 스코프가 될 수 있습니다. 이때 현재 코루틴은 부모로서의 역할을 수행하게 됩니다.</p>
<p>이전 예제를 보다 관용적인 방식으로 구조화 하는 방법은 아래와 같습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferredResult = async &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="string">&quot;World!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello, <span class="subst">$&#123;deferredResult.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; </span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>범위가 wrapping runBlocking 호출에 의해 제공되기 때문에 더 이상 GlobalScope가 필요하지 않습니다. 또한 자식 <code>Coroutine</code>이 끝날 때까지 기다릴 필요가 없습니다. <code>runBlocking</code>은 모든 자식이 자신의 실행을 완료하기 전에 완료 될 때까지 기다릴 것이므로 주 스레드는 <code>runBlocking</code>에 의해 블록 상태를 유지합니다.</p>
<h3 id="The-coroutineScope-builder"><a href="#The-coroutineScope-builder" class="headerlink" title="The coroutineScope builder"></a>The coroutineScope builder</h3><p><code>runBlocking</code>을 사용하는 것은 <code>coroutine</code> 내부에서 권장하지 않을 수 있음을 알 수 있을 것이다. 이는 Kotlin팀이 <code>coroutine</code> 내부에서 현재 스레드가 블록되지 않길 원하기도 했고, 대신 <code>suspending function</code>을 사용하길 권하고 있습니다. runBlocking에 해당하는 중단은 coroutineScope 빌더입니다.</p>
<p><code>coroutineScope</code>는 모든 자식 코루틴이 실행을 완료 할 때까지 현재의 coroutine을 일시 중단합니다. 다음은 Kotlin 문서에서 직접 취한 예제입니다:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task from runBlocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; <span class="comment">// Creates a new coroutine scope</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>) </span><br><span class="line">            println(<span class="string">&quot;Task from nested launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task from coroutine scope&quot;</span>) <span class="comment">// This line will be printed before nested launch</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Coroutine scope is over&quot;</span>) <span class="comment">// This line is not printed until nested launch completes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Beyond-the-basics"><a href="#Beyond-the-basics" class="headerlink" title="Beyond the basics"></a>Beyond the basics</h2><p>여기에서 설명하는 기본 구성 요소는 실제로 코 틀린의 coroutines 개념의 가장 큰 측면이 아닙니다. 우리는 <code>channel</code>, <code>producer</code> 및 <code>consumer</code> 등을 사용하여 동시성이 필요한 것을 정말 멋지게 표현하기 위해 <code>coroutine</code>을 사용할 수 있습니다. 그러나 우리는 먼저 이러한 빌딩 블록을 이해해야하며 그 위에 더 높은 추상화를 만들기 시작해야한다고 생각합니다.</p>
<p><code>coroutine</code>에 관해서는 많은 이야기가 있습니다.이 기사는 물론 표면적인 내용이 많긴 하지만, 이 글이 코루틴과 <code>suspending function</code>을 더 잘 이해하는데 도움이 되기를 바랍니다.</p>
<p>특정 부분에 대해 더 궁금하거나 이 글이 도움이 된다면 저에게 알려주시면 좋을꺼 같습니다. 만약 자잘한 실수가 보이면 망설이지 말고 알려주시구요.</p>
<h2 id="Very-helpful-resources"><a href="#Very-helpful-resources" class="headerlink" title="Very helpful resources"></a>Very helpful resources</h2><p>조금 시간을 할애 할 수 있다면, Kotlin Conf에서 Roman Elizarov가 발표했던 코루틴 관련 영상을 보시길 추천합니다. </p>
<h3 id="Coroutines-in-practice"><a href="#Coroutines-in-practice" class="headerlink" title="Coroutines in practice"></a>Coroutines in practice</h3><p>이 강연에서 Roman은 코루틴에 대해 아주 빠르게 요약하고 이어서 <code>channels</code>, <code>actors</code> 등을 사용하여 코루틴을 아주 잘 사용하는 방법을 설명하고 있습니다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=a3agLJQ6vt8">KotlinConf 2018 - Kotlin Coroutines in Practice by Roman Elizarov</a></li>
</ul>
<h3 id="Kotlin-conf-2017"><a href="#Kotlin-conf-2017" class="headerlink" title="Kotlin conf 2017"></a>Kotlin conf 2017</h3><p>2017 Kotlin conf에서 발표했던 내용 역시 여전히 유용합니다.</p>
<ul>
<li>Introduction to Coroutines : 이것은 기본적으로 내 기사의 내용이지만 보다 정확하고 나은 설명이 포함되어 있습니다</li>
<li>Deep Dive into Coroutines : 함수 및 coroutine을 실제로 중단시키는 방법에 대한 세부 정보를 설명합니다. 매우 계몽적인</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/03/04/DIARY/20190304/">20190304</a><a class="next" href="/2019/03/02/Kotlin/Kotlin_With_Spring/">Kotlin With Spring</a></div><script src="https://utteranc.es/client.js" repo="thefeeling/thefeeling.github.io" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://thefeeling.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 카테고리</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ARCHITECTURE/">ARCHITECTURE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/">AWS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DATABASE/">DATABASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DDD/">DDD</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DIARY/">DIARY</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MESSAGING/">MESSAGING</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Persistence/">Persistence</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 태그</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 과거</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/13/DIARY/20210813/">20210813</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/09/ARCHITECTURE/DATA_INTENSIVE_APPLICATION/">데이터 중심 어플리케이션 설계 - 7장 트랜잭션</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/DIARY/20210808/">20210808</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/05/DIARY/20210805/">20210805</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/DIARY/20210801/">20210801</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/30/DIARY/20210730/">20210730</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/28/DIARY/20210728/">20210728</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/27/DIARY/20210727/">20210727</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/27/Spring/MVC_RequestParam/">MVC와 WebFlux에서의 @ReqeustParam</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/27/Kotlin/Kotlin_In_Action/">Kotlin-In-Action Generics</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Choi's Dev.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;startOnload&quot;:true}" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=1.0.0"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="ko"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Kotlin Cookbook | Choi's Dev</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-203671947-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kotlin Cookbook</h1><a id="logo" href="/.">Choi's Dev</a><p class="description">Software Engineer, Backend-Developer</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 홈</i></a><a href="/archives/"><i class="fa fa-archive"> 아카이브</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kotlin Cookbook</h1><div class="post-meta">2021-03-03<span> | </span><span class="category"><a href="/categories/Kotlin/">Kotlin</a></span></div><div class="post-content"><h1 id="Kotlin-Cookbook"><a href="#Kotlin-Cookbook" class="headerlink" title="Kotlin Cookbook"></a>Kotlin Cookbook</h1><h2 id="10장"><a href="#10장" class="headerlink" title="10장"></a>10장</h2><h4 id="레시피-10-1-use로-리소스-관리하기"><a href="#레시피-10-1-use로-리소스-관리하기" class="headerlink" title="레시피 10.1 - use로 리소스 관리하기"></a>레시피 10.1 - use로 리소스 관리하기</h4><ul>
<li>코틀린에서는 자바의 <code>try-with-resources</code> 구조를 지원하지 않음</li>
<li>대신, <code>Closeable</code> 인터페이스의 확장함수 <code>use</code>를 제공하며, <code>Reader</code>와 <code>File</code>에는 <code>useLine</code> 확장함수를 추가</li>
<li><code>useLine</code>의 경우, <code>BufferedReader.use</code>에게 처리를 위임하며, 해당 확장함수는 <code>try-catch-finally</code>로 예외처리를 하는 전형적인 구조를 확장함수로 만들어놓았음</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="meta">@RequireKotlin(<span class="meta-string">&quot;1.2&quot;</span>, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = <span class="meta-string">&quot;Requires newer compiler version to be inlined correctly.&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Closeable?, R&gt;</span> T.<span class="title">use</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> exception: Throwable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        exception = e</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            apiVersionIsAtLeast(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) -&gt; <span class="keyword">this</span>.closeFinally(exception)</span><br><span class="line">            <span class="keyword">this</span> == <span class="literal">null</span> -&gt; &#123;&#125;</span><br><span class="line">            exception == <span class="literal">null</span> -&gt; close()</span><br><span class="line">            <span class="keyword">else</span> -&gt;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    close()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (closeException: Throwable) &#123;</span><br><span class="line">                    <span class="comment">// cause.addSuppressed(closeException) // ignored here</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">get10LongestWordsInDictionary</span><span class="params">()</span></span> = File(<span class="string">&quot;/usr/share/dict/words&quot;</span>).useLines &#123; line -&gt;</span><br><span class="line">    <span class="comment">// line type Kotlin Sequence</span></span><br><span class="line">    line.filter &#123; it.length &gt; <span class="number">20</span> &#125;</span><br><span class="line">        .sortedByDescending &#123; it.length &#125;</span><br><span class="line">        .take(<span class="number">10</span>)</span><br><span class="line">        .toList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="레시피-10-2-파일에-기록하기"><a href="#레시피-10-2-파일에-기록하기" class="headerlink" title="레시피 10.2 - 파일에 기록하기"></a>레시피 10.2 - 파일에 기록하기</h4><ul>
<li>본문 전체를 다시 쓰고 싶다면 <code>writeText</code>, 붙여쓰고 싶다면 <code>appendText</code></li>
<li>위 확장함수도 역시, <code>FileOutputStream(this).use &#123; it.write(array) &#125;</code> 확장함수에게 처리를 위임<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = File(<span class="string">&quot;./myfile.txt&quot;</span>)</span><br><span class="line">file.writeText(<span class="string">&quot;Data&quot;</span>)</span><br><span class="line">file.appendText(<span class="string">&quot;\nHello&quot;</span>)</span><br><span class="line">file.appendText(<span class="string">&quot;\nWorld&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="11장"><a href="#11장" class="headerlink" title="11장"></a>11장</h2><h4 id="레시피-11-1-코틀린-버전-알아내기"><a href="#레시피-11-1-코틀린-버전-알아내기" class="headerlink" title="레시피 11.1 - 코틀린 버전 알아내기"></a>레시피 11.1 - 코틀린 버전 알아내기</h4><ul>
<li><code>KotlinVersion.CURRENT</code>을 참조하면 시멘틱버져닝 형태의 코틀린 버젼 값을 알아낼 수 있음.</li>
<li><code>KotlinVersion</code>의 구현을 살펴보면 쉽게 알 수 있지만, Comparable 인터페이스를 구현하고 있으므로 비교가 가능<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;version = <span class="subst">$&#123;KotlinVersion.CURRENT&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;KotlinVersion.CURRENT &lt; KotlinVersion(major = <span class="number">1</span>, minor = <span class="number">2</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;KotlinVersion.CURRENT &lt; KotlinVersion(major = <span class="number">1</span>, minor = <span class="number">2</span>, patch = <span class="number">41</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="레시피-11-2-반복적으로-람다-실행하기"><a href="#레시피-11-2-반복적으로-람다-실행하기" class="headerlink" title="레시피 11.2 - 반복적으로 람다 실행하기"></a>레시피 11.2 - 반복적으로 람다 실행하기</h4><ul>
<li><code>repeat</code> 확장함수를 사용하면, 인자로 넘어가는 람다 구문이 지정한 횟수만큼 실행됨.</li>
<li><code>contract</code>: 컴파일러에게 함수의 호출횟수와 타입캐스팅을 도와주기위해 도입</li>
<li><code>@InlineOnly</code>: 자바 상호 운용을 할때, 자바쪽에서 해당 구현을 참조하지 못하도록 마킹 역할 수행</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="레시피-11-3-완벽한-When-강제하기"><a href="#레시피-11-3-완벽한-When-강제하기" class="headerlink" title="레시피 11.3 - 완벽한 When 강제하기"></a>레시피 11.3 - 완벽한 When 강제하기</h4><ul>
<li>코틀린에서의 <code>When</code>절은 문과 식의 역할을 모두 할 수 있다.</li>
<li>식으로 사용하는 경우, <code>else</code>까지 붙여 완벽한 형태로 사용해야 함.</li>
<li>문으로 사용할 경우, 완벽하게 else까지 붙여서 사용할 수 있도록 강제도 할 수 있음. <code>exhaustive</code> 확장 속성을 추가하면 가능하다.<ul>
<li><em>TODO: Kotlin 1.3.72 환경에서 구문 에러가 발생.</em><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printMod3</span><span class="params">(n: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (n % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; println(<span class="string">&quot;<span class="variable">$n</span> % 3 = 0&quot;</span>)</span><br><span class="line">        <span class="number">2</span> -&gt; println(<span class="string">&quot;<span class="variable">$n</span> % 3 = 1&quot;</span>)</span><br><span class="line">        <span class="number">3</span> -&gt; println(<span class="string">&quot;<span class="variable">$n</span> % 3 = 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printMod3SingleStatement</span><span class="params">(n: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> (n % <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; println(<span class="string">&quot;<span class="variable">$n</span> % 3 = 0&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; println(<span class="string">&quot;<span class="variable">$n</span> % 3 = 1&quot;</span>)</span><br><span class="line">    <span class="number">3</span> -&gt; println(<span class="string">&quot;<span class="variable">$n</span> % 3 = 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">&quot;problems&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="레시피-11-4-정규표현식과-함께-replace-함수-사용하기"><a href="#레시피-11-4-정규표현식과-함께-replace-함수-사용하기" class="headerlink" title="레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기"></a>레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기</h4><ul>
<li><p>문자열 중 부분 문자열을 수정하고 싶을 경우 <code>replace</code>함수를 사용.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">replace</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    oldValue: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    newValue: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    ignroeCase: <span class="type">Boolean</span> = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">replace</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    regex: <span class="type">Regex</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    replacement: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: String</span><br></pre></td></tr></table></figure></li>
<li><p>1)의 <code>replace</code>의 경우 자바의 replaceAll과 동일</p>
</li>
<li><p>2)의 <code>replace</code>의 경우 첫 번째 인자의 타입의 Regex를 받기 때문에 1)과는 전혀 다른 메소드</p>
</li>
<li><p>아래는 간단한 회문(Palindrome) 예제</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPal</span><span class="params">(string: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> testString = string</span><br><span class="line">            .toLowerCase()</span><br><span class="line">            .replace(<span class="string">&quot;&quot;&quot;[\W+]&quot;&quot;&quot;</span>.toRegex(), <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> testString == testString.reversed()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isPalindrome</span><span class="params">()</span></span> = <span class="keyword">this</span>.toLowerCase()</span><br><span class="line">        .replace(<span class="string">&quot;&quot;&quot;[\W+]&quot;&quot;&quot;</span>.toRegex(), <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .let &#123; it == it.reversed() &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="레시피-11-5-바이너리-문자열로-변환하고-되돌리기"><a href="#레시피-11-5-바이너리-문자열로-변환하고-되돌리기" class="headerlink" title="레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기"></a>레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기</h4><ul>
<li>숫자를 바이너리 문자열로, 바이너리 문자열을 다시 숫자로 파싱할때 <code>toString(radix = 2)</code>, <code>toInt(radix = 2)</code>와 같은 함수를 사용하면 쉽게 가능<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `paddedBinaryString`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> strings = (<span class="number">0.</span><span class="number">.15</span>)</span><br><span class="line">            .map &#123; it.toString(radix = <span class="number">2</span>)</span><br><span class="line">            .padStart(<span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>) &#125;</span><br><span class="line">    assertEquals(strings, listOf(</span><br><span class="line">            <span class="string">&quot;0000&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;0010&quot;</span>, <span class="string">&quot;0011&quot;</span>, <span class="string">&quot;0100&quot;</span>, <span class="string">&quot;0101&quot;</span>, <span class="string">&quot;0110&quot;</span>, <span class="string">&quot;0111&quot;</span>, <span class="string">&quot;1000&quot;</span>, <span class="string">&quot;1001&quot;</span>, <span class="string">&quot;1010&quot;</span>, <span class="string">&quot;1011&quot;</span>, <span class="string">&quot;1100&quot;</span>, <span class="string">&quot;1101&quot;</span>, <span class="string">&quot;1110&quot;</span>, <span class="string">&quot;1111&quot;</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    assertEquals(strings.map &#123; it.toInt(<span class="number">2</span>) &#125;, listOf(</span><br><span class="line">            <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span></span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="레시피-11-6-실행-가능한-클래스-만들기"><a href="#레시피-11-6-실행-가능한-클래스-만들기" class="headerlink" title="레시피 11.6 - 실행 가능한 클래스 만들기"></a>레시피 11.6 - 실행 가능한 클래스 만들기</h4><ul>
<li>클래스에서 <code>invoke</code> 연산자를 오버로딩 한다.</li>
<li>코틀린은 연산자 오버로딩을 기본으로 지원하고 있으며, 지원하는 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/operator-overloading.html">링크</a> 참고하면 된다.</li>
<li>아래는 오픈 API를 호출하여 JSON 응답을 Gson을 통하여 역직렬화 하는 예제이며, 이에 대한 실행은 <code>invoke</code> 연산자를 통하여 실행한다.</li>
<li>아래 코드를 보면 잘 알겠지만, 클래스를 인스턴스화하면 invoke 함수를 바로 호출하는 것이 가능하며, 필요하다면 메소드에 인자를 추가하는 것도 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">AstroResult</span> </span>(</span><br><span class="line">    <span class="keyword">val</span> message: String,</span><br><span class="line">    <span class="keyword">val</span> number: Number,</span><br><span class="line">    <span class="keyword">val</span> people: List&lt;Assignment&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span></span>(</span><br><span class="line">    <span class="keyword">val</span> craft: String,</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstroRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson = Gson()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: AstroResult = (</span><br><span class="line">        gson.fromJson(URL(<span class="string">&quot;http://api.open-notify.org/astros.json&quot;</span>)</span><br><span class="line">            .readText(), AstroResult::<span class="keyword">class</span>.java)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `AstroRequest Test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = AstroRequest()()</span><br><span class="line">    assertThat(result.message, `<span class="keyword">is</span>`(<span class="string">&quot;success&quot;</span>))</span><br><span class="line">    assertThat(result.number.toInt(), greaterThanOrEqualTo(<span class="number">0</span>))</span><br><span class="line">    assertThat(result.people.size, `<span class="keyword">is</span>`(result.number.toInt()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="레시피-11-7-경과-시간-측정하기"><a href="#레시피-11-7-경과-시간-측정하기" class="headerlink" title="레시피 11.7 - 경과 시간 측정하기"></a>레시피 11.7 - 경과 시간 측정하기</h4><ul>
<li><code>measureTimeMills</code> 혹은 <code>measureNanoTime</code>를 사용한다.</li>
<li>위 함수들은 람다를 인자로 받기 때문에 고차 함수이며 <code>inline</code>으로 선언 되어 있다. 실제 실행은 <code>System.currentTimeMillis</code> 메소드에게 위임한다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">measureTimeMillis</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doubleIt</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100L</span>)</span><br><span class="line">    println(<span class="string">&quot;doubling <span class="variable">$x</span> with on thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exec</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;Runtime.getRuntime().availableProcessors()&#125;</span> processors&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> time = measureTimeMillis &#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">                .map &#123; doubleIt(it) &#125;</span><br><span class="line">                .sum()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Sequential stream took <span class="subst">$&#123;time&#125;</span>ms&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time = measureTimeMillis &#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .map &#123; doubleIt(it) &#125;</span><br><span class="line">                .sum()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Parallel stream took <span class="subst">$&#123;time&#125;</span>ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IntStream</code>을 사용하여 sum을 구하는 예제이며, Parallel로 돌렸을때와 Sequential로 돌렸을 때의 경과 시간 측정을 위해 작성했다.</li>
</ul>
<h4 id="레시피-11-8-스레드-시작하기"><a href="#레시피-11-8-스레드-시작하기" class="headerlink" title="레시피 11.8 - 스레드 시작하기"></a>레시피 11.8 - 스레드 시작하기</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">thread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    isDaemon: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contextClassLoader: <span class="type">ClassLoader</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    priority: <span class="type">Int</span> = <span class="number">-1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Thread</span><br></pre></td></tr></table></figure>

<ul>
<li>코틀린은 스레드를 쉽게 생성하고 시작할 수 있도록 확장 함수를 제공함.</li>
<li>잔여 스레드가 모두 데몬 스레드일 경우, 어플리케이션은 종료된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">threadStart</span><span class="params">(isDaemon: <span class="type">Boolean</span> = <span class="literal">false</span>, isJoin: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> = (<span class="number">0.</span><span class="number">.5</span>).forEach &#123;</span><br><span class="line">    <span class="keyword">val</span> sleepTime = Random.nextLong(<span class="number">0.</span>.<span class="number">1000L</span>)</span><br><span class="line">    <span class="keyword">val</span> thread = thread(isDaemon = isDaemon) &#123;</span><br><span class="line">        Thread.sleep(sleepTime)</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span> for <span class="variable">$it</span> after <span class="variable">$sleepTime</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isJoin) thread.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5개의 스레드를 생성하는 예제이며, 데몬스레드 유무에 따라 바로 종료될수도 아닐수도 있는 코드이다.</li>
<li>순차 실행을 원한다면 <code>join()</code> 메소드를 사용</li>
</ul>
<h4 id="레시피-11-9-TODO로-완성-강제하기"><a href="#레시피-11-9-TODO로-완성-강제하기" class="headerlink" title="레시피 11.9 - TODO로 완성 강제하기"></a>레시피 11.9 - TODO로 완성 강제하기</h4><ul>
<li>함수 구현을 완성하지 않으면 예외를 던지는 TODO 함수를 사용하면 된다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">TODO</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> = <span class="keyword">throw</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">TODO</span><span class="params">(reason: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> = <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;An operation is not implemented: <span class="variable">$reason</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>함수의 시그니처는 위와 같으며, <code>reason</code>에는 미구현에 대한 사유를 넣어주면 되고, 발생하는 예외는 <code>NotImplementedError</code>가 발생하며 해당 클래스의 상위 클래스와 인터페이스는 <code>Error - Throwable</code> 이다.</li>
</ul>
<h4 id="레시피-11-10-Random의-무작위-동작-이해하기"><a href="#레시피-11-10-Random의-무작위-동작-이해하기" class="headerlink" title="레시피 11.10 - Random의 무작위 동작 이해하기"></a>레시피 11.10 - Random의 무작위 동작 이해하기</h4><ul>
<li>난수 생성은 자바와 같이 Random 클래스를 활용<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `nextInt with no args gives any int`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = Random.nextInt()</span><br><span class="line">    assertTrue(value <span class="keyword">in</span> <span class="built_in">Int</span>.MIN_VALUE..<span class="built_in">Int</span>.MAX_VALUE)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `nextInt with range gives value between 0 and limit`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = Random.nextInt(<span class="number">10</span>)</span><br><span class="line">    assertTrue(value <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `nextInt with min and max gives value between them`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = Random.nextInt(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    assertTrue(value <span class="keyword">in</span> <span class="number">5.</span><span class="number">.10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `nextInt with range returns value <span class="keyword">in</span> range`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = Random.nextInt(<span class="number">7.</span><span class="number">.12</span>)</span><br><span class="line">    assertTrue(value <span class="keyword">in</span> <span class="number">7.</span><span class="number">.12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>nextInt()</code>의 구현 부분을 살펴보면, 동반 객체에서 추상 클래스에 선언된 모든 메서드를 defaultPlatformRandom에 위임하고 있으며, 해당 defaultPlatformRandom은 internal로 선언되어 있음을 확인할 수 있다. </li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/-default/">코틀린 문서</a>를 확인해보면 <code>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</code> 난수 생성 시 스레드 세이프한 성격을 보장한다고 나와 있다.</li>
</ul>
<h4 id="레시피-11-11-함수-이름에-특수-문자-사용하기"><a href="#레시피-11-11-함수-이름에-특수-문자-사용하기" class="headerlink" title="레시피 11.11 - 함수 이름에 특수 문자 사용하기"></a>레시피 11.11 - 함수 이름에 특수 문자 사용하기</h4><ul>
<li>작명하기 아주 어려운 상황 혹은 테스트에서만 사용하는 것을 권한다.</li>
<li>함수명을 백틱(``)으로 감싸 놓으면 특수 문자 등을 활용할 수 있다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `nextInt with min and max gives value between them`<span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="레시피-11-12-자바에게-예외-알리기"><a href="#레시피-11-12-자바에게-예외-알리기" class="headerlink" title="레시피 11.12 - 자바에게 예외 알리기"></a>레시피 11.12 - 자바에게 예외 알리기</h4><ul>
<li>코틀린의 모든 예외는 기본적으로 Unchecked Exception이다. 코틀린 컴파일러가 예외를 강제하지 않으며 굳이 잡는다면 try catch finally로 잡는 방법도 있지만 강제 사항은 아니다.</li>
<li>자바에서처럼 <code>throws</code>키워드를 사용하여 예외가 발생할 수 있음을 알릴 수 없기 때문에 자바에서 만약 코틀린 코드를 사용한다면 이를 알릴 수 있는 장치가 필요하게 된다. <code>@Throws</code> 어노테이션을 활용하면 이것이 가능하다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">houstonWeHaveAProblem</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> IOException(<span class="string">&quot;File or resource not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>위와 같이 어노테이션을 사용하게 되면, 자바 컴파일러는 IOException에 대비해야 하는 내용을 알게 된다.</li>
<li>어노테이션을 명시하지 않고, 만약 자바코드에서 예외를 캐치하려고 한다면 컴파일이 실패하거나 불필요한 코드가 존재한다는 컴파일러 워닝을 만나게 될 것이다.</li>
<li><code>@Throws</code> 어노테이션의 역할을 다시 정리하자면, 자바/코틀린의 통합을 위해 그리고 코틀린 코드에서 발생하는 예외를 자바 코드에서 대비하기 위해 존재하는 것이다.</li>
</ul>
<hr>
<h2 id="12장"><a href="#12장" class="headerlink" title="12장"></a>12장</h2><h4 id="레시피-12-1-확장을-위해-스프링-관리-빈-클래스-오픈하기"><a href="#레시피-12-1-확장을-위해-스프링-관리-빈-클래스-오픈하기" class="headerlink" title="레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기"></a>레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기</h4><ul>
<li>스프링에서는 빈으로 관리되는 클래스들 대부분이 프록시 기반으로 작동하게 된다.</li>
<li>코틀린 클래스는 기본적으로 <code>final</code> 식별자를 달고 나오기 때문에 프록시를 동작이 안되게 된다. 이를 해결하기 위해서는 별도로 <code>kotlin-spring</code> 빌드 플러그인을 사용하여 스프링에서 관리하는 <code>@Component</code>,<br><code>@Service</code>으로 마킹된 클래스들이 확장 가능한 클래스 식별자인 <code>open</code>로 컴파일리 되도록 설정해줘야 한다.<ul>
<li><code>all-open</code> 플러그인을 사용해도 되지만, 대부분 <code>kotlin-spring</code>플러그인이 커버한다.</li>
</ul>
</li>
<li>프록시는 실제 컴포넌트 메소드 호출을 가로채 호출 전후로 많은 일을 수행하게 된다. 인자에 대한 유효값 체크와 트랜잭션 등이 아주 대표적인 케이스이다. </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.stereotype.Service </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">public</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span>: kotlin.<span class="built_in">Unit</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>플러그인을 적용하여 코드를 컴파일 결과이다.</li>
<li><code>@Component</code>, <code>@Async</code>, <code>@Transactional</code>, <code>@Cacheable</code>, <code>@SpringBootTest</code> 들이 open이 되는 마킹 어노테이션들이며 사실상 대부분을 커버한다고 보면 된다. <code>@Component</code>의 경우 이를 사용하는 하위 어노테이션중에 친숙한 <code>@Configuration</code>, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>, <code>@Repository</code> 들이 있다.</li>
</ul>
<h4 id="레시피-12-2-코틀린-data-클래스로-퍼시스턴스-구현하기"><a href="#레시피-12-2-코틀린-data-클래스로-퍼시스턴스-구현하기" class="headerlink" title="레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기"></a>레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기</h4><ul>
<li><p>JPA 관점에서 코틀린 <code>data class</code>는 두 가지 문제가 존재함</p>
<ul>
<li><code>data class</code>는 기본 생성자를 만들지 않음.</li>
<li>불변 속성(<code>val</code>)을 강조하는 data class의 성격</li>
</ul>
</li>
<li><p>기본 생성자를 만드는 부분에 대한 해결책은 <code>no-arg</code> 플러그인을 사용하는 방법이 존재한다.</p>
<blockquote>
<p>no-arg 플러그인으로 만든 기본 생성자의 접근 제어자는 <code>public</code>이고, 실제 코드에서는 접근이 불가능하며 리플렉션을 통한 접근만 가능하다고 한다.</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">&quot;org.jetbrains.kotlin.plugin.noarg&quot;</span> version <span class="string">&quot;1.4.10&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noArg &#123;</span><br><span class="line">    <span class="keyword">annotation</span>(<span class="string">&quot;com.my.Annotation&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>no-arg</code> 플러그인을 활용하는 방법도 좋지만, 빌드 설정에 마킹 어노테이션등을 명시해야 하는 불편함이 존재한다. 이를 개선하여 사용할 수 있는 플러그인이 바로 <code>kotlin-jpa</code> 플러그인이다.</p>
<ul>
<li><code>@Entity</code></li>
<li><code>@Embeddable</code></li>
<li><code>@MappedSuperClass</code></li>
</ul>
</li>
<li><p><code>data class</code>는 기본적으로 <code>hashCode</code>, <code>equals</code>, <code>toString</code>을 자동생성한다. JPA의 엔티티로 자동생성한 값을 사용하게 될 경우 발생할 수 있는 문제와 아래와 같다.</p>
<ul>
<li>양방향 엔티티 바인딩을 사용할 경우, 경우에 따라 순환 참조를 만나게 될 수 있다.</li>
<li>불변 프로퍼티 사용을 권하는 data class와 다르게 필드 값을 계속 변경해야 하기 때문에 var로 선언해두고 사용해야 하는 JPA의 성격이 매우 상이함.</li>
</ul>
</li>
<li><p>이러한 부분 때문에 차라리 class를 그대로 사용하는 것이 나을 수 있다. 하지만, class도 코틀린에서는 기본적으로 상속이 불가능한 형태인 final 키워드가 붙어져 있는 형태기 때문에, 프록시를 사용하는 JPA-하이버네이트의 상황상 이를 <code>open</code> 클래스로 바꿔줘야 하는 불편함이 생긴다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.3.1.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.9.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.plugin.spring&#x27;</span> version <span class="string">&#x27;1.3.72&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.plugin.jpa&#x27;</span> version <span class="string">&#x27;1.3.72&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allOpen &#123;</span><br><span class="line">    <span class="keyword">annotation</span>(<span class="string">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class="line">    <span class="keyword">annotation</span>(<span class="string">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class="line">    <span class="keyword">annotation</span>(<span class="string">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>위와 같이, kotlin-jpa 플러그인을 선언하고 open을 할 마킹 어노테이션을 지정해주면 실제로 컴파일한 클래스는 아래와 같다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class="line"><span class="comment">// Implementation of methods is not available</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.daniel.kotlin_in_action</span><br><span class="line"></span><br><span class="line"><span class="meta">@javax</span>.persistence.Entity </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">public</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">var</span> age: kotlin.<span class="built_in">Long</span>? <span class="comment">/* compiled code */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@field:javax</span>.persistence.Id <span class="meta">@field:javax</span>.persistence.GeneratedValue <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">var</span> id: kotlin.<span class="built_in">Long</span>? <span class="comment">/* compiled code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">var</span> name: kotlin.String <span class="comment">/* compiled code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="레시피-12-3-의존성-주입하기"><a href="#레시피-12-3-의존성-주입하기" class="headerlink" title="레시피 12.3 - 의존성 주입하기"></a>레시피 12.3 - 의존성 주입하기</h4><ul>
<li>스프링에서는 복잡한 의존성 주입 과정 그리고 빈과 빈의 연결을 컨테이너에서 처리해준다.</li>
<li>코틀린에서는 필드 레벨 빈 의존성 주입을 할 경우 <code>lateinit var</code> 구조를 활용해야 한다. 생성자 기반의 주입도 가능하다.</li>
<li>생성자 방식의 의존성 주입이 스프링에서 선호하는 의존성 주입 방식이긴 하나, 경우에 따라 필드 레벨의 주입이 필요한 경우도 있다. </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceByConstructorInjection</span></span>(<span class="keyword">val</span> contentService: ContentService)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceByConstructorInjectionWithFieldAutowired</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> contentService: ContentService)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceByConstructorInjectionWithAutowired</span> <span class="meta">@Autowired</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> contentService: ContentService)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceByFieldLevelInjection</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> contentService: ContentService</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 다양한 형태로 의존성 주입을 받는 것이 가능하다. <code>@Autowired</code>를 굳이 안붙여서도 사용 가능한 1번의 형태가 가장 간편한 방법이고 스프링에서 추천하는 의존성 주입 방식이다.</li>
</ul>
<hr>
<h2 id="13장-코루틴과-구조적-동시성"><a href="#13장-코루틴과-구조적-동시성" class="headerlink" title="13장 - 코루틴과 구조적 동시성"></a>13장 - 코루틴과 구조적 동시성</h2><h4 id="레시피-13-1-코루틴-빌더-선택하기"><a href="#레시피-13-1-코루틴-빌더-선택하기" class="headerlink" title="레시피 13.1 - 코루틴 빌더 선택하기"></a>레시피 13.1 - 코루틴 빌더 선택하기</h4><ul>
<li><p><code>GlobalScope</code>의 <code>async</code>와 <code>launch</code>는 사용하지 말자</p>
<ul>
<li>취소되지 않으면 어플리케이션 전체 수명주기에 걸쳐 실행됨.</li>
</ul>
</li>
<li><p><code>runBlocking</code> 빌더</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T    </span><br></pre></td></tr></table></figure>
<ul>
<li>블록 내 모든 코루틴이 종료될 때까지 현재 스레드를 블록</li>
<li><code>suspend</code> 키워드가 붙은 함수가 아니기 때문에, 일반 함수에서도 호출 가능</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>launch</code> 빌더</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job</span><br></pre></td></tr></table></figure>
<ul>
<li>해당값에서 리턴값을 받을 필요가 없을 때 사용</li>
<li><code>Job</code>을 리턴, 취소 가능</li>
<li>코루틴 컨텍스트(<code>context</code>)를 지정하여 다른 코루틴과 상태 공유가 가능</li>
<li><code>start</code> 인자의 열거형으로 <code>DEFAULT</code>, <code>LAZY</code>, <code>ATOMIC</code>, <code>UNDISPATCHED</code> 값을 사용할 수 있다.</li>
</ul>
</li>
<li><p><code>async</code> 빌더</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Deferred&lt;T&gt;    </span><br></pre></td></tr></table></figure>
<ul>
<li>값을 리턴해야 할 경우 사용</li>
<li><code>launch</code> 빌더처럼 CoroutineContext와 CoroutineStart 파라미터를 받을 수 있으며, 기본값이 설정되어 있다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(Random.nextLong(<span class="number">1000L</span>))</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> firstSum = async &#123;</span><br><span class="line">        println(Thread.currentThread().name)</span><br><span class="line">        add(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> secondSum = async &#123;</span><br><span class="line">        println(Thread.currentThread().name)</span><br><span class="line">        add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Awaiting concurrent sums...&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> total = firstSum.await() + secondSum.await()</span><br><span class="line">    println(<span class="string">&quot;Total is <span class="variable">$total</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefaultDispatcher-worker-1</span><br><span class="line">Awaiting concurrent sums...</span><br><span class="line">DefaultDispatcher-worker-2</span><br><span class="line">Total is 11</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>위 예제의 실행 결과를 보면 <code>async</code> 빌더는 기본 디스패처를 사용하는 것을 확인할 수 있다.</li>
<li><code>delay</code> 함수는 코루틴 실행 스레드를 블록하지 않고 대기 상태로 만든다.</li>
</ul>
</li>
<li><p><code>coroutineScope</code> 빌더</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">coroutineScope</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="keyword">val</span> coroutine = ScopeCoroutine(uCont.context, uCont)</span><br><span class="line">        coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ul>
<li><code>coroutineScope</code> 빌더는 함수 종료 전 모든 코루틴이 완료될때까지 기다리는 일수 중단 함수이다. 굳이 코루틴의 완료 유무를 확인할 필요가 없다.</li>
<li>메인 스레드를 블록하지 않지만, 반드시 다른 일시 중단 함수의 일부로서 호출해야 된다.</li>
<li>코루틴이 하나라도 실패하면 나머지 코루틴을 취소하며, 완료 유무를 확인하지 않고 균형 있는 제어와 에러 처리를 달성하고 루틴이 실패하는 경우를 처리하지 않는 것을 방지한다.</li>
</ul>
</li>
</ul>
<h4 id="레시피-13-2-async-await를-withContext로-변경하기"><a href="#레시피-13-2-async-await를-withContext로-변경하기" class="headerlink" title="레시피 13.2 - async/await를 withContext로 변경하기"></a>레시피 13.2 - async/await를 withContext로 변경하기</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T    </span><br></pre></td></tr></table></figure>

<ul>
<li><code>async</code> 코루틴을 시작하고 <code>await</code>로 기다리는 코드를 간소화하고 싶다면 <code>withContext</code>로 대체가 가능하다.</li>
<li>공식 문서에서는 <strong>주어진 코루틴 컨텍스트와 함께 명시한 일시정지 블록을 호출하고, 완료될 떄까지 일시정지한 후에 그 결과를 리턴한다.</strong> 라고 나와 있다. 다시 말해, <code>async ~ await</code>의 호출 구조를 <code>withContext</code>로 단순화하는 것이 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">retrieve1</span><span class="params">(url: <span class="type">String</span>)</span></span> = coroutineScope &#123;</span><br><span class="line">    async(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;Retrieving data on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="string">&quot;asyncResults&quot;</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">retrieve2</span><span class="params">(url: <span class="type">String</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    println(<span class="string">&quot;Retrieving data on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="string">&quot;asyncResults&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = retrieve1(<span class="string">&quot;www.mysite.com&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result2 = retrieve2(<span class="string">&quot;www.mysite.com&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;printing result on <span class="subst">$&#123;Thread.currentThread().name&#125;</span> <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;printing result on <span class="subst">$&#123;Thread.currentThread().name&#125;</span> <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrieving data on DefaultDispatcher-worker-1</span><br><span class="line">Retrieving data on DefaultDispatcher-worker-1</span><br><span class="line">printing result on main asyncResults</span><br><span class="line">printing result on main asyncResults</span><br></pre></td></tr></table></figure>


<ul>
<li><p><code>retrieve1</code>과 같이 메소드를 작성하게 되면 Intellij에서 <code>merge call chain to &#39;withContext&#39;</code>라는 문구와 함께 withContext로 대체 할 것을 제안하는 것을 확인할 수 있다.</p>
</li>
<li><p>각 suspend 함수는 기본 디스패처에서 호출이 되며, 메인 스레드 메인 함수에서 <code>await</code> 호출 없이 결과를 받아 오는 것을 확인할 수 있다.</p>
</li>
</ul>
<h4 id="레시피-13-3-디스패처-사용하기"><a href="#레시피-13-3-디스패처-사용하기" class="headerlink" title="레시피 13.3 - 디스패처 사용하기"></a>레시피 13.3 - 디스패처 사용하기</h4><ul>
<li>IO 혹은 다른 작업을 위한 전용 스레드풀을 이용할 때는 <code>Dispatchers</code> 클래스의 적당한 디스패처를 골라 사용하면 된다.</li>
<li>코루틴은 <code>CorutineContext</code> 컨텍스트 내에서 실행되며 코루틴 컨텍스트에는 <code>CoroutineDispatcher</code> 클래스의 인스턴스가 포함되어 있다. </li>
<li><strong>디스패처의 역할은 코루틴이 어떤 스레드에서 혹은 어떤 스레드풀에서 실행할지를 결정한다.</strong> 디스패처의 종류는 아래와 같다.<ul>
<li>IO:  File IO 혹은 Network IO와 같은 IO Intensive 작업을 위해 디자인된 디스패처이며, On-Demand 공유 풀을 사용한다.</li>
<li>Default:  공유 백그라운드 스레드풀을 사용하며, CPU Bound 상황에 어울린다.</li>
<li>Unconfined</li>
</ul>
</li>
<li>디스패처의 명시는 <code>async</code>, <code>launch</code>, <code>withContext</code>의 호출 인자에 넘겨서 지정하는 것이 가능하다.</li>
</ul>
<h4 id="레시피-13-4-자바-스레드-풀에서-코루틴-실행하기"><a href="#레시피-13-4-자바-스레드-풀에서-코루틴-실행하기" class="headerlink" title="레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기"></a>레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기</h4><ul>
<li>자바의 <code>ExecutorService</code>의 <code>asCoroutineDispatcher</code> 확장 함수 호출을 통해 코루틴의 스레드풀 생성이 가능하다. </li>
<li><code>asCoroutineDispatcher</code> 함수는 <code>ExecutorService</code>의 인스턴스를 <code>ExecutorCoroutineDispatcher</code>의 구현으로 변환한다. </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCoroutineDispatcher</span>: <span class="type">CoroutineDispatcher</span></span>(), Closeable &#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@suppress</span> */</span></span><br><span class="line">    <span class="meta">@ExperimentalStdlibApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : AbstractCoroutineContextKey&lt;CoroutineDispatcher, ExecutorCoroutineDispatcher&gt;(</span><br><span class="line">        CoroutineDispatcher,</span><br><span class="line">        &#123; it <span class="keyword">as</span>? ExecutorCoroutineDispatcher &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">val</span> executor: Executor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ExecutorCoroutineDispatcher</code>는 <code>close</code> 함수를 호출하지 않으면 계속 실행되기 때문에, 해당 함수 호출은 필수다. <code>ExecutorCoroutineDispatcher</code> 클래스는 추상 클래스로 구현 클래스인 <code>ThreadPoolDispatcher</code>의 <code>close</code> 메소드를 살펴보면 ExecutorService의 <code>shutdown</code> 메소드를 호출하는 것을 확인할 수 있다.</li>
<li><code>Closeable</code> 인터페이스를 구현하여 <code>close</code> 혹은 <code>shutdown</code> 호출에 대한 부분은 해당 인터페이스 구현에 맡겼으며 코틀린에서는 <code>use</code> 블록을 사용하여 사용 후 쉽게 종료가 가능하다. <blockquote>
<p>자바와 같이 try<del>with</del>resource 구문이 없는 코틀린에서는 Closeable 인터페이스 use를 사용하여 자원 해제를 하게 된다. <a href="#10%EC%9E%A5">링크</a> 참고</p>
</blockquote>
</li>
</ul>
<h4 id="레시피-13-5-코루틴-취소하기"><a href="#레시피-13-5-코루틴-취소하기" class="headerlink" title="레시피 13.5 - 코루틴 취소하기"></a>레시피 13.5 - 코루틴 취소하기</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">jobCancelExec</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">            repeat(<span class="number">100</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;Job: I&#x27;m waiting <span class="variable">$it</span>...&quot;</span>)</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">500L</span>)</span><br><span class="line">        println(<span class="string">&quot;main: That&#x27;s enough waiting&quot;</span>)</span><br><span class="line">        job.cancel()</span><br><span class="line">        job.join()</span><br><span class="line">        println(<span class="string">&quot;main: Done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>launch</code>, <code>async</code> 빌더 함수는 공통적으로 Job 타입을 리턴하게 되는데, 해당 타입의 cancel 메소드를 호출하면 해당 잡을 취소하는 것이 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">jobTimeout</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        withTimeout(<span class="number">1000L</span>) &#123;</span><br><span class="line">            repeat(<span class="number">50</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;Job: I&#x27;m waiting <span class="variable">$it</span>...&quot;</span>)</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withTimeout</span><span class="params">(timeMillis: <span class="type">Long</span>, block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T</span><br></pre></td></tr></table></figure>
<ul>
<li><code>withTimeout</code> 혹은 <code>withTimeoutOrNull</code>과 같은 메소드를 호출하여 취소하는 것도 가능하며, 타임아웃이 초과하면 <code>TimeoutCancellationException</code>이 발생한다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Job: I&#x27;m waiting 0...</span><br><span class="line">Job: I&#x27;m waiting 1...</span><br><span class="line">...(생략)</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1000 ms</span><br><span class="line">	at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:158)</span><br><span class="line">	at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:128)</span><br><span class="line">	at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)</span><br><span class="line">	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)</span><br><span class="line">	at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<h4 id="레시피-13-6-코루틴-디버깅"><a href="#레시피-13-6-코루틴-디버깅" class="headerlink" title="레시피 13.6 - 코루틴 디버깅"></a>레시피 13.6 - 코루틴 디버깅</h4></li>
<li>JVM의 실행 플래그(<code>-Dkotlinx.coroutines.debug</code>)를 추가하면 코루틴 이름등과 같은 실행정보를 확인할 수 있다. Intelli에서는 VM Options에 해당 플래그 값을 추가하면 된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">retrieve1</span><span class="params">(url: <span class="type">String</span>)</span></span> = coroutineScope &#123;</span><br><span class="line">    async(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;Retrieving data on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="string">&quot;asyncResults&quot;</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">retrieve2</span><span class="params">(url: <span class="type">String</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    println(<span class="string">&quot;Retrieving data on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="string">&quot;asyncResults&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = retrieve1(<span class="string">&quot;www.mysite.com&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result2 = retrieve2(<span class="string">&quot;www.mysite.com&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;printing result on <span class="subst">$&#123;Thread.currentThread().name&#125;</span> <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;printing result on <span class="subst">$&#123;Thread.currentThread().name&#125;</span> <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrieving data on DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">Retrieving data on DefaultDispatcher-worker-1 @coroutine#1</span><br><span class="line">printing result on main @coroutine#1 asyncResults</span><br><span class="line">printing result on main @coroutine#1 asyncResults</span><br></pre></td></tr></table></figure>
<ul>
<li>스레드 이름 뒤에 <code>@coroutine#2</code>가 붙은 것을 확인할 수 있는데, <code>CoroutineName</code> 클래스를 사용하여 직접 이름을 붙이는 것도 가능하다. 위 코드에서 <code>retrieve1</code>, <code>retrieve2</code>의 컨텍스트를 인자 부분을 아래와 같이 수정하면 된다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">retrieve1</span><span class="params">(url: <span class="type">String</span>)</span></span> = coroutineScope &#123;</span><br><span class="line">    async(Dispatchers.IO + CoroutineName(name = <span class="string">&quot;async&quot;</span>)) &#123;</span><br><span class="line">        println(<span class="string">&quot;Retrieving data on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="string">&quot;asyncResults&quot;</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">retrieve2</span><span class="params">(url: <span class="type">String</span>)</span></span> = withContext(Dispatchers.IO + CoroutineName(name = <span class="string">&quot;withContext&quot;</span>)) &#123;</span><br><span class="line">    println(<span class="string">&quot;Retrieving data on <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="string">&quot;asyncResults&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// coroutine이라는 이름 대신 지정한 이름을 노출</span><br><span class="line">Retrieving data on DefaultDispatcher-worker-1 @async#2</span><br><span class="line">Retrieving data on DefaultDispatcher-worker-1 @withContext#1</span><br><span class="line">printing result on main @coroutine#1 asyncResults</span><br><span class="line">printing result on main @coroutine#1 asyncResults</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/04/22/Persistence/JPA_ACCESS/">JPA @Access</a><a class="next" href="/2020/09/22/DIARY/20200922/">20200922</a></div><script src="https://utteranc.es/client.js" repo="thefeeling/thefeeling.github.io" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://thefeeling.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 카테고리</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ARCHITECTURE/">ARCHITECTURE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/">AWS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DATABASE/">DATABASE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DDD/">DDD</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DIARY/">DIARY</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MESSAGING/">MESSAGING</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Persistence/">Persistence</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 태그</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 과거</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/13/DIARY/20210813/">20210813</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/09/ARCHITECTURE/DATA_INTENSIVE_APPLICATION/">데이터 중심 어플리케이션 설계 - 7장 트랜잭션</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/DIARY/20210808/">20210808</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/05/DIARY/20210805/">20210805</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/DIARY/20210801/">20210801</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/30/DIARY/20210730/">20210730</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/28/DIARY/20210728/">20210728</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/27/DIARY/20210727/">20210727</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/27/Spring/MVC_RequestParam/">MVC와 WebFlux에서의 @ReqeustParam</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/27/Kotlin/Kotlin_In_Action/">Kotlin-In-Action Generics</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Choi's Dev.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;startOnload&quot;:true}" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=1.0.0"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>